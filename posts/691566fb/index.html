<!doctype html><html class="theme-next mist use-motion" lang="zh-Hans"><head><link href="http://static.niceweb.me/css/code.min.css" rel="stylesheet"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="规范,JavaScript,"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="前端编码规范—JavaScript规范前端编码规范—JavaScript规范前端编码规范—JavaScript规范全局命名空间污染与 IIFEIIFE（立即执行的函数表达式）严格模式变量声明变量的命名理解 javascript 的定义域声明提前总是使用带类型判断的比较判断明智地使用真假判断变量赋值时的逻辑操作三元条件判断（if 的快捷方法）分号嵌套函数语句块内的函数声明异常标准特性简易的原型继承使"><meta name="keywords" content="规范,JavaScript"><meta property="og:type" content="article"><meta property="og:title" content="前端编码规范—JavaScript规范"><meta property="og:url" content="http://blog.iqianduan.wang/posts/691566fb/index.html"><meta property="og:site_name" content="前端观察"><meta property="og:description" content="前端编码规范—JavaScript规范前端编码规范—JavaScript规范前端编码规范—JavaScript规范全局命名空间污染与 IIFEIIFE（立即执行的函数表达式）严格模式变量声明变量的命名理解 javascript 的定义域声明提前总是使用带类型判断的比较判断明智地使用真假判断变量赋值时的逻辑操作三元条件判断（if 的快捷方法）分号嵌套函数语句块内的函数声明异常标准特性简易的原型继承使"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-10-23T07:32:36.791Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="前端编码规范—JavaScript规范"><meta name="twitter:description" content="前端编码规范—JavaScript规范前端编码规范—JavaScript规范前端编码规范—JavaScript规范全局命名空间污染与 IIFEIIFE（立即执行的函数表达式）严格模式变量声明变量的命名理解 javascript 的定义域声明提前总是使用带类型判断的比较判断明智地使用真假判断变量赋值时的逻辑操作三元条件判断（if 的快捷方法）分号嵌套函数语句块内的函数声明异常标准特性简易的原型继承使"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"right",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"作者"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.iqianduan.wang/posts/691566fb/"><title>前端编码规范—JavaScript规范 | 前端观察</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">前端观察</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description"></h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>文章</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.iqianduan.wang/posts/691566fb/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="7*"><meta itemprop="description" content="尘世中一枚迷途的小前端er"><meta itemprop="image" content="https://avatars0.githubusercontent.com/u/7498226?v=4&u=60bc9fd6e63144c1fd975814086a9fd328da90c6&s=400"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="前端观察"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">前端编码规范—JavaScript规范</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T17:37:35+08:00">2017-08-03 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/规范/" itemprop="url" rel="index"><span itemprop="name">规范</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/posts/691566fb/#SOHUCS" itemprop="discussionUrl"><span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="posts/691566fb/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><title>前端编码规范—JavaScript规范</title><meta charset="utf-8"></head><body><div id="preview-contents" class="note-content"><div id="wmd-preview" class="preview-content"></div><div id="wmd-preview-section-179" class="wmd-preview-section preview-content"></div><div id="wmd-preview-section-180" class="wmd-preview-section preview-content"><h1 id="前端编码规范javascript规范"><center>前端编码规范—JavaScript规范</center></h1><div><div class="toc"><div class="toc"><ul><li><a href="#前端编码规范javascript规范">前端编码规范—JavaScript规范</a><ul><li><a href="#全局命名空间污染与-iife">全局命名空间污染与 IIFE</a></li><li><a href="#iife立即执行的函数表达式">IIFE（立即执行的函数表达式）</a></li><li><a href="#严格模式">严格模式</a></li><li><a href="#变量声明">变量声明</a></li><li><a href="#变量的命名">变量的命名</a></li></ul></li><li><a href="#理解-javascript-的定义域">理解 javascript 的定义域</a><ul><li><a href="#声明提前">声明提前</a></li><li><a href="#总是使用带类型判断的比较判断">总是使用带类型判断的比较判断</a></li><li><a href="#明智地使用真假判断">明智地使用真假判断</a></li><li><a href="#变量赋值时的逻辑操作">变量赋值时的逻辑操作</a></li><li><a href="#三元条件判断if-的快捷方法">三元条件判断（if 的快捷方法）</a></li><li><a href="#分号">分号</a></li><li><a href="#嵌套函数">嵌套函数</a></li><li><a href="#语句块内的函数声明">语句块内的函数声明</a></li><li><a href="#异常">异常</a></li><li><a href="#标准特性">标准特性</a></li><li><a href="#简易的原型继承">简易的原型继承</a></li><li><a href="#使用闭包">使用闭包</a></li><li><a href="#切勿在循环中创建函数">切勿在循环中创建函数</a></li><li><a href="#eval-函数魔鬼">eval 函数（魔鬼）</a></li><li><a href="#this-关键字">this 关键字</a></li><li><a href="#数组和对象的属性迭代">数组和对象的属性迭代</a></li><li><a href="#数组和对象字面量">数组和对象字面量</a></li><li><a href="#修改内建对象的原型链">修改内建对象的原型链</a></li><li><a href="#自定义-tostring-方法">自定义 toString() 方法</a></li><li><a href="#圆括号">圆括号</a></li><li><a href="#字符串">字符串</a></li></ul></li></ul></div></div></div></div><div id="wmd-preview-section-181" class="wmd-preview-section preview-content"><h2 id="全局命名空间污染与-iife">全局命名空间污染与 IIFE</h2><p>总是将代码包裹成一个 IIFE即时执行方法（Immediately-Invoked Function Expression），用以创建独立隔绝的定义域。这一举措可防止全局命名空间被污染。</p><p>IIFE 还可确保你的代码不会轻易被其它全局命名空间里的代码所修改（比如第三方库，window 引用，被覆盖的未定义的关键字等等）。<br>现在很多第三方的类库、插件、控件、框架、模块儿等很多都是 IIFE这样的写法。<br><strong>不推荐</strong></p></div><div id="wmd-preview-section-182" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>,<br>    y = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.x + <span class="hljs-string">' '</span> + <span class="hljs-built_in">window</span>.y);<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-183" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>,<br>        y = <span class="hljs-number">100</span>;<br>    w.console.log((w.x === <span class="hljs-literal">undefined</span>) + <span class="hljs-string">' '</span> + (w.y === <span class="hljs-literal">undefined</span>));<br>}(<span class="hljs-built_in">window</span>));<br></code></pre></div><div id="wmd-preview-section-184" class="wmd-preview-section preview-content"><h2 id="iife立即执行的函数表达式">IIFE（立即执行的函数表达式）</h2><p>无论何时，想要创建一个新的封闭的定义域，那就用 IIFE。它不仅避免了干扰，也使得内存在执行完后立即释放。</p><p>所有脚本文件建议都从 IIFE 开始。</p><p>立即执行的函数表达式的执行括号应该写在外包括号内。虽然写在内还是写在外都是有效的，但写在内使得整个表达式看起来更像一个整体，因此推荐这么做。IIFE的写法很多、也很灵活，为了方便项目的结合、代码的易读性和代码格式的统一，我们推荐下面的书写格式。</p><p><strong>不推荐</strong></p></div><div id="wmd-preview-section-185" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{})();<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-186" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}());<br></code></pre><p>所以用下列写法来格式化你的 IIFE 代码：</p></div><div id="wmd-preview-section-187" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$, w, d</span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br>    $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>        w.alert(d.querySelectorAll(<span class="hljs-string">'div'</span>).length);<br>    });<br>}(jQuery, <span class="hljs-built_in">window</span>, <span class="hljs-built_in">document</span>));<br></code></pre></div><div id="wmd-preview-section-188" class="wmd-preview-section preview-content"><h2 id="严格模式">严格模式</h2><p>ECMAScript5 严格模式可在整个脚本或独个方法内被激活。它对应不同的 javascript 语境会做更加严格的错误检查。严格模式也确保了 javascript 代码更加的健壮，运行的也更加快速。</p><p>严格模式会阻止使用在未来很可能被引入的预留关键字。</p><p>你应该在你的脚本中启用严格模式，最好是在独立的 IIFE 中应用它。避免在你的脚本第一行使用它而导致你的所有脚本都启动了严格模式，这有可能会引发一些第三方类库的问题。<br><strong>不推荐</strong></p></div><div id="wmd-preview-section-189" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-pi">'use strict'</span>;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br>    <span class="hljs-comment">// some code</span><br>}());<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-190" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br>    <span class="hljs-comment">// some code</span><br>}());<br></code></pre></div><div id="wmd-preview-section-191" class="wmd-preview-section preview-content"><h2 id="变量声明">变量声明</h2><p>总是使用 <code>var</code> 来声明变量。如不指定 <code>var</code>，变量将被隐式地声明为全局变量，这将对变量难以控制。如果没有声明，变量处于什么定义域就变得不清（可以是在 Document 或 Window 中，也可以很容易地进入本地定义域）。所以，请总是使用 var 来声明变量。</p><p>采用严格模式带来的好处是，当你手误输入错误的变量名时，它可以通过报错信息来帮助你定位错误出处。<br><strong>不推荐</strong></p></div><div id="wmd-preview-section-192" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs">x = <span class="hljs-number">10</span>;<br>y = <span class="hljs-number">100</span>;<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-193" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>,<br>    y = <span class="hljs-number">100</span>;<br></code></pre></div><div id="wmd-preview-section-194" class="wmd-preview-section preview-content"><h2 id="变量的命名">变量的命名</h2><ol><li rel="1">变量名必须以大写字母（A到Z)、小写宇母（a到z)或下划线（_）开头，其他的字符可以用字母、下划线或数字（0到9)。变量名称中不能有空格、+ 、-号等其他符号。</li><li rel="2">不能使用JavaScript中的关键字作为变量名。在JavaScript中定义了多个关键字，这些关键字是JavaScript内部使用的，不能作为变量的名称。例如var、int、double、true等都不能作为变量的名称。</li><li rel="3">在对变量命名时，最好把变暈名的意义与其代表的内容对应起来，以便能方便地区分变量的食义。例如，today这样的变量就很容易让人明白其代表的内容。</li><li rel="4">JavaScript变量名是区分大小写的，因此在使用时必须确保大小写相同。不同大小写的变量,例如sum、Sum、SUM,将被视为不同的变量。</li><li rel="5">变量命名法:项目中使用驼峰命名法。<br>例：</li></ol></div><div id="wmd-preview-section-195" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-keyword">var</span> myObj = {<br>        a:<span class="hljs-string">'a'</span>,<br>        b:<span class="hljs-string">'b'</span><br>    };<br><span class="hljs-keyword">var</span> myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>{<br>    <span class="hljs-built_in">console</span>.log(a);<br>};<br><span class="hljs-keyword">var</span> myArray = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>];<br></code></pre><p>关于驼峰命名的更多了解请移步。<a href="http://baike.baidu.com/link?url=OHHicH004xhq-0HsKXwwX_GNAbZ44apAezO249VvbAY7gVSVzrnR00xsXfHJSWcUVeW47qm4xWW35RxetZPoXoQ-dQ9mEmSgsr91zKqbbEci1eVy2iEqXxGstundF3B_-Nu69r_IEq91f1nAaX6e8W8BpqKMD_tTUEcLTR837oX2ptW3Tjw9OR-aSmTElBCy" target="_blank">传送门</a></p></div><div id="wmd-preview-section-196" class="wmd-preview-section preview-content"><h1 id="理解-javascript-的定义域">理解 javascript 的定义域</h1><p>在 javascript 中变量和方法定义会自动提升到执行之前。javascript 只有 <code>function</code>级的定义域，而无其他很多编程语言中的块定义域，所以使得你在某一 <code>function</code> 内的某语句和循环体中定义了一个变量，此变量可作用于整个 <code>function</code>内，而不仅仅是在此语句或循环体中，因为它们的声明被 javascript 自动提升了。</p><p>我们通过例子来看清楚这到底是怎么一回事：<br><strong>原 function</strong></p></div><div id="wmd-preview-section-197" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; a; i++) {<br>        <span class="hljs-keyword">var</span> b = i * i;<br>        <span class="hljs-built_in">console</span>.log(b);<br>    }<br>    <span class="hljs-keyword">if</span>(a === <span class="hljs-number">10</span>) {<br>        <span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>            <span class="hljs-built_in">console</span>.log(a);<br>        };<br>        f();<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Mr. X!'</span>);<br>    }<br>    x();<br>}());<br></code></pre><p><strong>被 js 提升过后</strong></p></div><div id="wmd-preview-section-198" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br>    <span class="hljs-keyword">var</span> a,<br>        i,<br>        b,<br>        f;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Mr. X!'</span>);<br>    }<br><br>    a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; a; i++) {<br>        b = i * i;<br>        <span class="hljs-built_in">console</span>.log(b);<br>    }<br>    <span class="hljs-keyword">if</span>(a === <span class="hljs-number">10</span>) {<br>        f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>            <span class="hljs-built_in">console</span>.log(a);<br>        };<br>        f();<br>    }<br>    x();<br>}());<br></code></pre><p>根据以上提升过程，你是否可理解以下代码？</p><p><strong>有效代码</strong></p></div><div id="wmd-preview-section-199" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>    i = <span class="hljs-number">5</span>;<br>    x();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i; i &lt; a; i++) {<br>        <span class="hljs-built_in">console</span>.log(b);<br>        <span class="hljs-keyword">var</span> b = i * i;<br>    }<br>    <span class="hljs-keyword">if</span>(a === <span class="hljs-number">10</span>) {<br>        f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>            <span class="hljs-built_in">console</span>.log(a);<br>        };<br>        f();<br>        <span class="hljs-keyword">var</span> f;<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Mr. X!'</span>);<br>    }<br>}());<br></code></pre><p>正如你所看到的这段令人充满困惑与误解的代码导致了出人意料的结果。只有良好的声明习惯，也就是下一章节我们要提到的声明规则，才能尽可能的避免这类错误风险。</p></div><div id="wmd-preview-section-200" class="wmd-preview-section preview-content"><h2 id="声明提前">声明提前</h2><p>为避免上一章节所述的变量和方法定义被自动提升造成误解，把风险降到最低，我们应该手动地显示地去声明变量与方法。也就是说，所有的变量以及方法，应当定义在 <code>function</code> 内的首行。</p><p>只用一个 <code>var</code> 关键字声明，多个变量用逗号隔开。<br><strong>不推荐</strong></p></div><div id="wmd-preview-section-201" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>        <span class="hljs-keyword">var</span> c = a * b * i;<br>    };<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{<br><br>    };<br>    <span class="hljs-keyword">var</span> d = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-keyword">return</span> d * d;<br>    };<br>    <span class="hljs-built_in">console</span>.log(x());<br>}());<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-202" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>,<br>        b = <span class="hljs-number">10</span>,<br>        i,<br>        c,<br>        d,<br>        x;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{<br><br>    };<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>        c = a * b * i;<br>    };<br>    d = <span class="hljs-number">100</span>;<br>    x = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-keyword">return</span> d * d;<br>    };<br>    <span class="hljs-built_in">console</span>.log(x());<br>}());<br></code></pre><p>把赋值尽量写在变量申明中。<br><strong>不推荐</strong></p></div><div id="wmd-preview-section-203" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a,<br>    b,<br>    c; <br>a = <span class="hljs-number">10</span>;<br>b = <span class="hljs-number">10</span>;<br>c = <span class="hljs-number">100</span>;<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-204" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs cpp">var a = <span class="hljs-number">10</span>,<br>    b = <span class="hljs-number">10</span>,<br>    c = <span class="hljs-number">100</span>;<br></code></pre></div><div id="wmd-preview-section-205" class="wmd-preview-section preview-content"><h2 id="总是使用带类型判断的比较判断">总是使用带类型判断的比较判断</h2><p>总是使用 <code>===</code> 精确的比较操作符，避免在判断的过程中，由 javascript 的强制类型转换所造成的困扰。</p><p>如果你使用 <code>===</code> 操作符，那比较的双方必须是同一类型为前提的条件下才会有效。</p><p>在只使用 <code>==</code> 的情况下，javascript 所带来的强制类型转换使得判断结果跟踪变得复杂，下面的例子可以看出这样的结果有多怪了：</p></div><div id="wmd-preview-section-206" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'0'</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">''</span> == <span class="hljs-literal">false</span>); <span class="hljs-comment">// true</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1'</span> == <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br><br>    <span class="hljs-keyword">var</span> x = {<br>        valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">'X'</span>;<br>        }<br>    };<br><br>    <span class="hljs-built_in">console</span>.log(x == <span class="hljs-string">'X'</span>);<br>}());<br></code></pre></div><div id="wmd-preview-section-207" class="wmd-preview-section preview-content"><h2 id="明智地使用真假判断">明智地使用真假判断</h2><p>当我们在一个 <code>if</code> 条件语句中使用变量或表达式时，会做真假判断。<code>if(a == true)</code> 是不同于 <code>if(a)</code> 的。后者的判断比较特殊，我们称其为真假判断。这种判断会通过特殊的操作将其转换为 <code>true</code> 或 <code>false</code>，下列表达式统统返回 <code>false：false，0，undefined，null，NaN，''</code>（空字符串）。这种真假判断在我们只求结果而不关心过程的情况下，非常的有帮助。</p><p>以下示例展示了真假判断是如何工作的：</p></div><div id="wmd-preview-section-208" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logTruthyFalsy</span>(<span class="hljs-params">expr</span>) </span>{<br>        <span class="hljs-keyword">if</span>(expr) {<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'truthy'</span>);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'falsy'</span>);<br>        }<br>    };<br><br>    logTruthyFalsy(<span class="hljs-literal">true</span>); <span class="hljs-comment">// truthy</span><br>    logTruthyFalsy(<span class="hljs-number">1</span>); <span class="hljs-comment">// truthy</span><br>    logTruthyFalsy({}); <span class="hljs-comment">// truthy</span><br>    logTruthyFalsy([]); <span class="hljs-comment">// truthy</span><br>    logTruthyFalsy(<span class="hljs-string">'0'</span>); <span class="hljs-comment">// truthy</span><br><br>    logTruthyFalsy(<span class="hljs-literal">false</span>); <span class="hljs-comment">// falsy</span><br>    logTruthyFalsy(<span class="hljs-number">0</span>); <span class="hljs-comment">// falsy</span><br>    logTruthyFalsy(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// falsy</span><br>    logTruthyFalsy(<span class="hljs-literal">null</span>); <span class="hljs-comment">// falsy</span><br>    logTruthyFalsy(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// falsy</span><br>    logTruthyFalsy(<span class="hljs-string">''</span>); <span class="hljs-comment">// falsy</span><br>}());<br></code></pre></div><div id="wmd-preview-section-209" class="wmd-preview-section preview-content"><h2 id="变量赋值时的逻辑操作">变量赋值时的逻辑操作</h2><p>逻辑操作符 <code>||</code> 和 <code>&amp;&amp;</code> 也可被用来返回布尔值。如果操作对象为非布尔对象，那每个表达式将会被自左向右地做真假判断。基于此操作，最终总有一个表达式被返回回来。这在变量赋值时，是可以用来简化你的代码的。</p><p><strong>不推荐</strong></p></div><div id="wmd-preview-section-210" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs cpp"><span class="hljs-keyword">if</span>(!x) {<br>    <span class="hljs-keyword">if</span>(!y) {<br>        x = <span class="hljs-number">1</span>;<br>    } <span class="hljs-keyword">else</span> {<br>        x = y;<br>    }<br>}<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-211" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs gherkin">x = x ||<span class="hljs-string"> y </span>||<span class="hljs-string"> 1;</span><br></code></pre><p>这一小技巧经常用来给方法设定默认的参数。</p></div><div id="wmd-preview-section-212" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">a, b</span>) </span>{<br>        a = a || <span class="hljs-number">1</span>;<br>        b = b || <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Result '</span> + a * b);<br>    }<br><br>    multiply(); <span class="hljs-comment">// Result 1</span><br>    multiply(<span class="hljs-number">10</span>); <span class="hljs-comment">// Result 10</span><br>    multiply(<span class="hljs-number">3</span>, <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// Result 3</span><br>    multiply(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// Result 45</span><br>}());<br></code></pre></div><div id="wmd-preview-section-213" class="wmd-preview-section preview-content"><h2 id="三元条件判断if-的快捷方法">三元条件判断（if 的快捷方法）</h2><p>用三元操作符分配或返回语句。在比较简单的情况下使用，避免在复杂的情况下使用。没人愿意用 10 行三元操作符把自己的脑子绕晕。</p><p><strong>不推荐</strong></p></div><div id="wmd-preview-section-214" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-keyword">if</span>(x === <span class="hljs-number">10</span>) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'valid'</span>;<br>} <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'invalid'</span>;<br>}<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-215" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-keyword">return</span> x === <span class="hljs-number">10</span> ? <span class="hljs-string">'valid'</span> : <span class="hljs-string">'invalid'</span>;<br></code></pre></div><div id="wmd-preview-section-216" class="wmd-preview-section preview-content"><h2 id="分号">分号</h2><p>总是使用分号，因为隐式的代码嵌套会引发难以察觉的问题。尤其是在压缩文件时，缺少分号往往会造成很多不必要的麻烦， 当然我们更要从根本上来杜绝这些问题。</p><p>javascript 中语句要以分号结束，否则它将会继续执行下去，不管换不换行。</p><p><strong>澄清：分号与函数</strong><br>分号需要用在表达式的结尾，而并非函数声明的结尾。区分它们最好的例子是：</p></div><div id="wmd-preview-section-217" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs actionscript"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>};<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre><p>当然，如果你不是分得特别清楚，那么最好都加上，因为如果是函数声明加了分号也不会报错，但是如果表达式不加分号，就会报错。</p></div><div id="wmd-preview-section-218" class="wmd-preview-section preview-content"><h2 id="嵌套函数">嵌套函数</h2><p>嵌套函数是非常有用的，比如用在持续创建和隐藏辅助函数的任务中。你可以非常自由随意地使用它们。但是，函数嵌套一般不超过3层，因为太多的函数嵌套会倒是逻辑的复杂性大幅增加，从而导致代码维护起来、团队中其他成员阅读起来都非常困难。</p></div><div id="wmd-preview-section-219" class="wmd-preview-section preview-content"><h2 id="语句块内的函数声明">语句块内的函数声明</h2><p>切勿在语句块内声明函数，在 ECMAScript5 的严格模式下，这是不合法的。函数声明应该在定义域的顶层。但在语句块内可将函数申明转化为函数表达式赋值给变量。</p><p><strong>不推荐</strong></p></div><div id="wmd-preview-section-220" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs actionscript"><span class="hljs-keyword">if</span> (x) {<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{}<br>}<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-221" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs actionscript"><span class="hljs-keyword">if</span> (x) {<br>    <span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{};<br>}<br></code></pre></div><div id="wmd-preview-section-222" class="wmd-preview-section preview-content"><h2 id="异常">异常</h2><p>基本上你无法避免出现异常，特别是在做大型开发和开发插件时（使用应用开发框架等等）。</p><p>在没有自定义异常的情况下，从有返回值的函数中返回错误信息一定非常的棘手，更别提多不优雅了。不好的解决方案包括了传第一个引用类型来接纳错误信息，或总是返回一个对象列表，其中包含着可能的错误对象。以上方式基本上是比较简陋的异常处理方式。适时可做自定义异常处理。</p><p>在复杂的环境中，你可以考虑抛出对象而不仅仅是字符串（默认的抛出值）。</p></div><div id="wmd-preview-section-223" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-keyword">if</span>(name === <span class="hljs-literal">undefined</span>) {<br>    <span class="hljs-keyword">throw</span> {<br>        name: <span class="hljs-string">'System Error'</span>,<br>        message: <span class="hljs-string">'A name should always be specified!'</span><br>    }<br>}<br></code></pre></div><div id="wmd-preview-section-224" class="wmd-preview-section preview-content"><h2 id="标准特性">标准特性</h2><p>总是优先考虑使用标准特性。为了最大限度地保证扩展性与兼容性，总是首选标准的特性，而不是非标准的特性（例如：首选 <code>string.charAt(3)</code> 而不是 <code>string[3]</code>；首选 DOM 的操作方法来获得元素引用，而不是某一应用特定的快捷方法）。</p></div><div id="wmd-preview-section-225" class="wmd-preview-section preview-content"><h2 id="简易的原型继承">简易的原型继承</h2><p>如果你想在 javascript 中继承你的对象，请遵循一个简易的模式来创建此继承。如果你预计你会遇上复杂对象的继承，那可以考虑采用一个继承库，比如 <a href="https://github.com/rauschma/proto-js/blob/master/Proto.js" target="_blank">Proto.js</a>。</p><p>简易继承请用以下方式：</p></div><div id="wmd-preview-section-226" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="language-javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br><br>    <span class="hljs-comment">// Constructor function</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Apple</span>(<span class="hljs-params">name</span>) </span>{<br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br>    <span class="hljs-comment">// Defining a method of apple</span><br>    Apple.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Eating '</span> + <span class="hljs-keyword">this</span>.name);<br>    };<br><br>    <span class="hljs-comment">// Constructor function</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GrannySmithApple</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-comment">// Invoking parent constructor</span><br>        Apple.prototype.constructor.call(<span class="hljs-keyword">this</span>, <span class="hljs-string">'Granny Smith'</span>);<br>    }<br>    <span class="hljs-comment">// Set parent prototype while creating a copy with Object.create</span><br>    GrannySmithApple.prototype = <span class="hljs-built_in">Object</span>.create(Apple.prototype);<br>    <span class="hljs-comment">// Set constructor to the sub type, otherwise points to Apple</span><br>    GrannySmithApple.prototype.constructor = GrannySmithApple;<br><br>    <span class="hljs-comment">// Calling a super method</span><br>    GrannySmithApple.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-comment">// Be sure to apply it onto our current object with call(this)</span><br>        Apple.prototype.eat.call(<span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Poor Grany Smith'</span>);<br>    };<br><br>    <span class="hljs-comment">// Instantiation</span><br>    <span class="hljs-keyword">var</span> apple = <span class="hljs-keyword">new</span> Apple(<span class="hljs-string">'Test Apple'</span>);<br>    <span class="hljs-keyword">var</span> grannyApple = <span class="hljs-keyword">new</span> GrannySmithApple();<br><br>    <span class="hljs-built_in">console</span>.log(apple.name); <span class="hljs-comment">// Test Apple</span><br>    <span class="hljs-built_in">console</span>.log(grannyApple.name); <span class="hljs-comment">// Granny Smith</span><br><br>    <span class="hljs-comment">// Instance checks</span><br>    <span class="hljs-built_in">console</span>.log(apple <span class="hljs-keyword">instanceof</span> Apple); <span class="hljs-comment">// true</span><br>    <span class="hljs-built_in">console</span>.log(apple <span class="hljs-keyword">instanceof</span> GrannySmithApple); <span class="hljs-comment">// false</span><br><br>    <span class="hljs-built_in">console</span>.log(grannyApple <span class="hljs-keyword">instanceof</span> Apple); <span class="hljs-comment">// true</span><br>    <span class="hljs-built_in">console</span>.log(grannyApple <span class="hljs-keyword">instanceof</span> GrannySmithApple); <span class="hljs-comment">// true</span><br><br>    <span class="hljs-comment">// Calling method that calls super method</span><br>    grannyApple.eat(); <span class="hljs-comment">// Eating Granny Smith\nPoor Grany Smith</span><br>}());<br></code></pre></div><div id="wmd-preview-section-227" class="wmd-preview-section preview-content"><h2 id="使用闭包">使用闭包</h2><p>闭包的创建也许是 js 最有用也是最易被忽略的能力了。关于闭包的深入理解本文不再更多的解释，如果想了解更多请移步。<a href="http://toutiao.com/a6189376318277386497/" target="_blank">传送门</a></p></div><div id="wmd-preview-section-228" class="wmd-preview-section preview-content"><h2 id="切勿在循环中创建函数">切勿在循环中创建函数</h2><p>在简单的循环语句中加入函数是非常容易形成闭包而带来隐患的。下面的例子就是一个典型的陷阱：</p><p><strong>不推荐</strong></p></div><div id="wmd-preview-section-229" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br><br>    <span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>        i;<br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numbers.length; i++) {<br>        w.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>            w.alert(<span class="hljs-string">'Index '</span> + i + <span class="hljs-string">' with number '</span> + numbers[i]);<br>        }, <span class="hljs-number">0</span>);<br>    }<br>}(<span class="hljs-built_in">window</span>));<br></code></pre><p>接下来的改进虽然已经解决了上述例子中的问题或 bug，但还是违反了不在循环中创建函数或闭包的原则。<br><strong>不推荐</strong></p></div><div id="wmd-preview-section-230" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br>    <span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>        i;<br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numbers.length; i++) {<br>        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, number</span>)</span>{<br>            w.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>                w.alert(<span class="hljs-string">'Index '</span> + index + <span class="hljs-string">' with number '</span> + number);<br>            }, <span class="hljs-number">0</span>);<br>        }(i, numbers[i]));<br>    }<br>}(<span class="hljs-built_in">window</span>));<br></code></pre><p>接下来的改进已解决问题，而且也遵循了规范。可是，你会发现看上去似乎过于复杂繁冗了，应该会有更好的解决方案吧。</p><p><strong>不完全推荐</strong></p></div><div id="wmd-preview-section-231" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br>    <span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>        i;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertIndexWithNumber</span>(<span class="hljs-params">index, number</span>) </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>            w.alert(<span class="hljs-string">'Index '</span> + index + <span class="hljs-string">' with number '</span> + number);<br>        };<br>    }<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numbers.length; i++) {<br>        w.setTimeout(alertIndexWithNumber(i, numbers[i]), <span class="hljs-number">0</span>);<br>    }<br>}(<span class="hljs-built_in">window</span>));<br></code></pre><p>将循环语句转换为函数执行的方式问题能得到立马解决，每一次循环都会对应地创建一次闭包。函数式的风格更加值得推荐，而且看上去也更加地自然和可预料。<br><strong>推荐</strong></p></div><div id="wmd-preview-section-232" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">w</span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br>    <span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>    numbers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">number, index</span>) </span>{<br>        w.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br>            w.alert(<span class="hljs-string">'Index '</span> + index + <span class="hljs-string">' with number '</span> + number);<br>        }, <span class="hljs-number">0</span>);<br>    });<br>}(<span class="hljs-built_in">window</span>));<br></code></pre></div><div id="wmd-preview-section-233" class="wmd-preview-section preview-content"><h2 id="eval-函数魔鬼">eval 函数（魔鬼）</h2><p><code>eval()</code> 不但混淆语境还很危险，总会有比这更好、更清晰、更安全的另一种方案来写你的代码，因此尽量不要使用 eval() 函数。</p></div><div id="wmd-preview-section-234" class="wmd-preview-section preview-content"><h2 id="this-关键字">this 关键字</h2><p>只在对象构造器、方法和在设定的闭包中使用 <code>this</code> 关键字。<code>this</code> 的语义在此有些误导。它时而指向全局对象（大多数时），时而指向调用者的定义域（在 <code>eval</code> 中），时而指向 DOM 树中的某一节点（当用事件处理绑定到 <code>html</code> 属性上时），时而指向一个新创建的对象（在构造器中），还时而指向其它的一些对象（如果函数被 <code>call()</code> 和 <code>apply()</code> 执行和调用时）。</p><p>正因为它是如此容易地被搞错，请限制它的使用场景：</p><ul><li>在构造函数中</li><li>在对象的方法中（包括由此创建出的闭包内）</li></ul></div><div id="wmd-preview-section-235" class="wmd-preview-section preview-content"><h2 id="数组和对象的属性迭代">数组和对象的属性迭代</h2><p>用 ECMAScript5 的迭代方法来迭代数组。使用 <code>Array.forEach</code> 或者如果你要在特殊场合下中断迭代，那就用 <code>Array.every</code>。</p></div><div id="wmd-preview-section-236" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-pi">    'use strict'</span>;<br><br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, index, arr</span>) </span>{<br>        <span class="hljs-built_in">console</span>.log(element + <span class="hljs-string">' at index '</span> + index + <span class="hljs-string">' in array '</span> + arr);<br><br>        <span class="hljs-keyword">if</span>(index !== <span class="hljs-number">5</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>    });<br><br>    <span class="hljs-keyword">var</span> obj = {<br>        a: <span class="hljs-string">'A'</span>,<br>        b: <span class="hljs-string">'B'</span>,<br>        <span class="hljs-string">'c-d-e'</span>: <span class="hljs-string">'CDE'</span><br>    };<br><br>    <span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, index, arr</span>) </span>{<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Key '</span> + element + <span class="hljs-string">' has value '</span> + obj[element]);<br>    });<br>}());<br></code></pre></div><div id="wmd-preview-section-237" class="wmd-preview-section preview-content"><h2 id="数组和对象字面量">数组和对象字面量</h2><p>用数组和对象字面量来代替数组和对象构造器。数组构造器很容易让人在它的参数上犯错。<br><strong>不推荐</strong></p></div><div id="wmd-preview-section-238" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs javascript"><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(x1, x2, x3);<br><span class="hljs-keyword">var</span> a2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(x1, x2);<br><span class="hljs-keyword">var</span> a3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(x1);<br><span class="hljs-keyword">var</span> a4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-239" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs kotlin"><span class="hljs-variable"><span class="hljs-keyword">var</span> a</span> = [x1, x2, x3];<br><span class="hljs-variable"><span class="hljs-keyword">var</span> a2</span> = [x1, x2];<br><span class="hljs-variable"><span class="hljs-keyword">var</span> a3</span> = [x1];<br><span class="hljs-variable"><span class="hljs-keyword">var</span> a4</span> = [];<br></code></pre><p>对象构造器不会有类似的问题，但是为了可读性和统一性，我们应该使用对象字面量。<br><strong>不推荐</strong></p></div><div id="wmd-preview-section-240" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs dart"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>o2.a = <span class="hljs-number">0</span>;<br>o2.b = <span class="hljs-number">1</span>;<br>o2.c = <span class="hljs-number">2</span>;<br>o2[<span class="hljs-string">'strange key'</span>] = <span class="hljs-number">3</span>;<br></code></pre><p><strong>推荐</strong></p></div><div id="wmd-preview-section-241" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs kotlin"><span class="hljs-variable"><span class="hljs-keyword">var</span> o</span> = {};<br><span class="hljs-variable"><span class="hljs-keyword">var</span> o2</span> = {<br>    a: <span class="hljs-number">0</span>,<br>    b: <span class="hljs-number">1</span>,<br>    c: <span class="hljs-number">2</span>,<br>    'strange key': <span class="hljs-number">3</span><br>};<br></code></pre></div><div id="wmd-preview-section-242" class="wmd-preview-section preview-content"><h2 id="修改内建对象的原型链">修改内建对象的原型链</h2><p>修改内建的诸如 <code>Object.prototype</code> 和 <code>Array.prototype</code> 是被严厉禁止的。修改其它的内建对象比如 <code>`Function.prototype</code>，虽危害没那么大，但始终还是会导致在开发过程中难以 <code>debug</code> 的问题，应当也要避免。</p></div><div id="wmd-preview-section-243" class="wmd-preview-section preview-content"><h2 id="自定义-tostring-方法">自定义 toString() 方法</h2><p>你可以通过自定义 <code>toString()</code> 来控制对象字符串化。这很好，但你必须保证你的方法总是成功并不会有其它副作用。如果你的方法达不到这样的标准，那将会引发严重的问题。如果<code>toString()</code> 调用了一个方法，这个方法做了一个断言，当断言失败，它可能会输出它所在对象的名称，当然对象也需要调用 <code>toString()</code>。</p></div><div id="wmd-preview-section-244" class="wmd-preview-section preview-content"><h2 id="圆括号">圆括号</h2><p>一般在语法和语义上真正需要时才谨慎地使用圆括号。不要用在一元操作符上，例如 delete，typeof 和 void，或在关键字之后，例如 return，throw，case，new 等。</p></div><div id="wmd-preview-section-245" class="wmd-preview-section preview-content"><h2 id="字符串">字符串</h2><p>统一使用单引号(‘’)，不使用双引号(“”)。这在创建 html 字符串非常有好处，因为之前我们HTML的规范中提到html属性都是用双引号”“包裹，所以在JavaScript中我们使用单引号从而避免相互干扰。</p></div><div id="wmd-preview-section-246" class="wmd-preview-section preview-content"><pre class="prettyprint hljs-dark"><code class="hljs applescript">var msg = 'This <span class="hljs-keyword">is</span> <span class="hljs-keyword">some</span> HTML &lt;<span class="hljs-keyword">div</span> <span class="hljs-type">class</span>=<span class="hljs-string">"makes-sense"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;';<br></code></pre></div><div id="wmd-preview-section-footnotes" class="preview-content"></div></div></body></html></div><div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持技术分享，您的支持将鼓励我继续创作！</div><div id="QR"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/pay.jpg" alt="7* WeChat Pay"><p>微信打赏</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/pay.jpg" alt="7* Alipay"><p>支付宝打赏</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> 7*</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://blog.iqianduan.wang/posts/691566fb/" title="前端编码规范—JavaScript规范">http://blog.iqianduan.wang/posts/691566fb/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/规范/" rel="tag"># 规范</a> <a href="/tags/JavaScript/" rel="tag"># JavaScript</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/b2743838/" rel="next" title="前端gulp自动构建说明"><i class="fa fa-chevron-left"></i> 前端gulp自动构建说明</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/dc7c062e/" rel="prev" title="前端编码规范—一般规范">前端编码规范—一般规范 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="SOHUCS"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/7498226?v=4&u=60bc9fd6e63144c1fd975814086a9fd328da90c6&s=400" alt="7*"><p class="site-author-name" itemprop="name">7*</p><p class="site-description motion-element" itemprop="description">尘世中一枚迷途的小前端er</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">13</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">15</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前端编码规范javascript规范"><span class="nav-number">1.</span> <span class="nav-text">前端编码规范—JavaScript规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全局命名空间污染与-iife"><span class="nav-number">1.1.</span> <span class="nav-text">全局命名空间污染与 IIFE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iife立即执行的函数表达式"><span class="nav-number">1.2.</span> <span class="nav-text">IIFE（立即执行的函数表达式）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#严格模式"><span class="nav-number">1.3.</span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量声明"><span class="nav-number">1.4.</span> <span class="nav-text">变量声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量的命名"><span class="nav-number">1.5.</span> <span class="nav-text">变量的命名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解-javascript-的定义域"><span class="nav-number">2.</span> <span class="nav-text">理解 javascript 的定义域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#声明提前"><span class="nav-number">2.1.</span> <span class="nav-text">声明提前</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总是使用带类型判断的比较判断"><span class="nav-number">2.2.</span> <span class="nav-text">总是使用带类型判断的比较判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#明智地使用真假判断"><span class="nav-number">2.3.</span> <span class="nav-text">明智地使用真假判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量赋值时的逻辑操作"><span class="nav-number">2.4.</span> <span class="nav-text">变量赋值时的逻辑操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三元条件判断if-的快捷方法"><span class="nav-number">2.5.</span> <span class="nav-text">三元条件判断（if 的快捷方法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分号"><span class="nav-number">2.6.</span> <span class="nav-text">分号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套函数"><span class="nav-number">2.7.</span> <span class="nav-text">嵌套函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语句块内的函数声明"><span class="nav-number">2.8.</span> <span class="nav-text">语句块内的函数声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">2.9.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准特性"><span class="nav-number">2.10.</span> <span class="nav-text">标准特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简易的原型继承"><span class="nav-number">2.11.</span> <span class="nav-text">简易的原型继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用闭包"><span class="nav-number">2.12.</span> <span class="nav-text">使用闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切勿在循环中创建函数"><span class="nav-number">2.13.</span> <span class="nav-text">切勿在循环中创建函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eval-函数魔鬼"><span class="nav-number">2.14.</span> <span class="nav-text">eval 函数（魔鬼）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-关键字"><span class="nav-number">2.15.</span> <span class="nav-text">this 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组和对象的属性迭代"><span class="nav-number">2.16.</span> <span class="nav-text">数组和对象的属性迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组和对象字面量"><span class="nav-number">2.17.</span> <span class="nav-text">数组和对象字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修改内建对象的原型链"><span class="nav-number">2.18.</span> <span class="nav-text">修改内建对象的原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义-tostring-方法"><span class="nav-number">2.19.</span> <span class="nav-text">自定义 toString() 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#圆括号"><span class="nav-number">2.20.</span> <span class="nav-text">圆括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">2.21.</span> <span class="nav-text">字符串</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">7*</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script type="text/javascript">!function(){var t,e,n,a,c="cyt9rGKH8",o="41c3e3f3b25a5ff73445fe3e4b1f42e9";if((window.innerWidth||document.documentElement.clientWidth)<960)window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='+c+"&conf="+o+'"><\/script>');else{t="https://changyan.sohu.com/upload/changyan.js",e=function(){window.changyan.api.config({appid:c,conf:o})},n=document.getElementsByTagName("head")[0]||document.head||document.documentElement,(a=document.createElement("script")).setAttribute("type","text/javascript"),a.setAttribute("charset","UTF-8"),a.setAttribute("src",t),"function"==typeof e&&(window.attachEvent?a.onreadystatechange=function(){var t=a.readyState;"loaded"!==t&&"complete"!==t||(a.onreadystatechange=null,e())}:a.onload=e),n.appendChild(a)}}()</script><script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script><script type="text/javascript">var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,o=-1,n=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),o=c.indexOf(e),(0<=s||0<=o)&&(a=!0,0==t&&(n=o))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=n){var l=n-20,p=n+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script></body></html>